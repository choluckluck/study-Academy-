<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ES6 에서 새로 도입된 Array 관련 메소드에 대해서 알아봅니다.</title>

<style type="text/css">

	table, th, td {border: solid 1px gray;}
	table {border-collapse: collapse; 
	       width: 150px;} 
	td {text-align: center;}            

</style>

</head>
<body>

<h2>내가 좋아하는 과일</h2>
<div id="div_fruit" style="display: flex;"> 
	<ul style="list-style-type: none; color:red;">
		<li>사과</li>
		<li>딸기</li>
		<li>수박</li>
		<li>참외</li>
	</ul>
	<ul style="list-style-type: none; color:blue;">
		<li>apple</li>
		<li>strawberry</li>
		<li>watermelon</li>
		<li>melon</li>
	</ul>
</div>

<div>
	<table id="tbl">
		<thead>
			<tr>
				<th>성명</th>
				<th>점수</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>홍길동</td>
				<td>90</td>
			</tr>
			<tr>
				<td>엄정화</td>
				<td>100</td>
			</tr>
			<tr>
				<td>이순신</td>
				<td>50</td>
			</tr>
			<tr>
				<td>유관순</td>
				<td>70</td>
			</tr>
			<tr>
				<td>김유신</td>
				<td>80</td>
			</tr>
		</tbody>
		<tfoot>
			<tr>
				<td>총점1</td>
				<td></td>
			</tr>
			<tr>
				<td>총점2</td>
				<td></td>
			</tr>
		</tfoot>	
	</table>
</div>
<br/>

<hr style="background-color: gold; height: 2px; border: none;">

<div id="display_all_fruit"></div>
<div>
	최저가격:&nbsp;<input type="text" id="minPrice" /> - 최고가격:&nbsp;<input type="text" id="maxPrice" />
	<button type="button" id="btnSearch">검색</button>
</div>
<div id="display_search_fruit"></div>

<script type="text/javascript">

	const li_list_1 = document.querySelectorAll("div#div_fruit > ul:first-child > li"); 
	
	console.log(li_list_1); // NodeList(4) [li, li, li, li] 
	// li_list_1 은 4개의 li 태그를 가지고 있는 NodeList(배열과 비슷한 구조)이다.
	
	const fruit_Arr_1 = [];
	for(let li of li_list_1) {
		fruit_Arr_1.push(li.innerText);
	}
	
	console.log(fruit_Arr_1); // (4) ['사과', '딸기', '수박', '참외']
	
	//////////////////////////////////////////////////////////////////
	
	// ---- ***** Array.from() ***** ---- //
	// ES6에서 새로 도입된 메소드로서 유사 배열 객체나 반복 가능한 객체를 실제 배열로 변환시켜주는 것이다.
	
	const li_list_2 = document.querySelectorAll("div#div_fruit > ul:last-child > li"); 
	
	const fruit_Arr_2 = Array.from(li_list_2);
	// Array.from(인수1); 에서 인수1은 배열로 변환하고자 하는 유사 배열 객체나 반복 가능한 객체가 들어온다.
	// 즉, Array.from(li_List_2); 은 NodeList(배열과 비슷한 구조)인 li_List_2를 실제 배열로 변환하여 준다. 
	console.log(fruit_Arr_2); // (4) [li, li, li, li]
	
	/*
	const fruit_Arr_3 = fruit_Arr_2.map(function(item, index, array){
	      return item.innerText;
	});
	*/
	// fruit_Arr_2 은 배열이 되었으므로 배열 메소드인 map()을 사용할 수 있게 된다. 
	// 매개변수가 item 1개이므로 (item) 대신에 ()를 생략한 item 을 사용하였으며, 처리할 내용이 return 만 있으므로 {} 및 return 을 생략하였다. 
	const fruit_Arr_3 = fruit_Arr_2.map(item=>item.innerText);
	
	console.log(fruit_Arr_3); // (4) ['apple', 'strawberry', 'watermelon', 'melon']
	
	////////////////////////////////////////////////////////////////////////////////
	
	const li_list_3 = document.querySelectorAll("div#div_fruit > ul:last-child > li");
	
	const fruit_Arr_4 = Array.from(li_list_3, item=>item.innerText);
	// Array.from(인수1, 인수2); 에서 인수1은 배열로 변환하고자 하는 유사 배열 객체나 반복 가능한 객체가 들어온다.
	// Array.from(인수1, 인수2); 에서 인수2는 배열 메소드인 map() 메소드와 기능이 흡사한 배열 요소에 대한 1:1 매핑 함수가 들어온다. 
	
	console.log(fruit_Arr_4); // (4) ['apple', 'strawberry', 'watermelon', 'melon']
	
	////////////////////////////////////////////////////////////////////////////////
	
	// ==== td 태그에 나열된 점수를 가지고 와서 합계 구하기 ==== //
	const td_List_point = document.querySelectorAll("table#tbl > tbody > tr > td:last-child"); 
	
	console.log(td_List_point); // NodeList(5) [td, td, td, td, td]
	
	const arr_td = Array.from(td_List_point); 
	console.log(arr_td); // (5) [td, td, td, td, td]
	
	const arr_point = arr_td.map(item=>Number(item.innerText));
	console.log(arr_point); //	(5) [90, 100, 50, 70, 80] 
	
	let sum = 0;
	for(let item of arr_point) {
		sum += item;
	}// end of for------------------
	
	console.log(sum); // 390 
	
	document.querySelector("table#tbl > tfoot > tr:first-child > td:last-child").innerHTML = `<span style='color:red'>${sum}</span>`;   
	//////////////////////////////////////////////////////////////////////////////////////////
	
	const arr2_point = Array.from(td_List_point, item=>Number(item.innerText));
	
	sum = 0;
	for(let item of arr2_point) {
		sum += item;
	}// end of for----------------------
	
	document.querySelector("table#tbl > tfoot > tr:last-child > td:last-child").innerHTML = `<span style='color:blue'>${sum}</span>`;
	
	/////////////////////////////////////////////////////////////////////////////////
	
	
	// ---- ***** Array.of() ***** ---- //
	// ES6에서 새로 도입된 메소드로서 전달받은 모든 인수를 배열의 요소로 하는 배열로 만들어 준다.
	const arr_digit = Array.of(1,2,3,4,5,6,7);
	console.log(arr_digit); // (7) [1, 2, 3, 4, 5, 6, 7]
	
	
	/////////////////////////////////////////////////////////////////////////////////
	
	
	// ---- ***** 배열명.find() ***** ---- //
	// ES6에서 새로 도입된 메소드로서 판별함수의 조건에 만족하는 배열요소가 있으면 첫번째 배열요소를 리턴 시켜주고 끝내고, 
	// 판별함수의 조건에 만족하는 배열요소가 없으면 undefinded
	
	const fruit_Arr_5 = [{name:'사과', price:1000},
		                 {name:'딸기', price:2000},
		                 {name:'사과', price:3000}];
	
/*	
	const fruit = fruit_Arr_5.find(function(item, index, array){
								     if(item.name === '사과') 
								    	 return item;
				  });
*/				  
	
	const fruit = fruit_Arr_5.find(item => item.name === '사과');
    // 판별함수의 조건에 만족하는 첫번째 배열요소를 리턴 시켜주고 끝내고, 판별함수의 조건에 만족하는 배열요소가 없으면 undefinded 
	
	console.log(fruit); //  {name: '사과', price: 1000}
	console.log(fruit.name); // 사과
	console.log(fruit.price); // 1000 
	
	
	const fruit_2 = fruit_Arr_5.find(item => item.name === '수박');
    // 판별함수의 조건에 만족하는 첫번째 배열요소를 리턴 시켜주고 끝내고, 판별함수의 조건에 만족하는 배열요소가 없으면 undefinded 
	
	console.log(fruit_2); // undefined
	
	/////////////////////////////////////////////////////////////////////////
	
	
	// ---- ***** 배열명.filter() ***** ---- //
	// 판별함수의 조건에 만족하는 배열요소가 있으면 모든 배열요소를 담은 배열로 리턴 시켜주고,
	// 판별함수의 조건에 만족하는 배열요소가 없으면 빈배열 [] 을 리턴시켜준다. 
	/*
	const apple_arr = fruit_Arr_5.filter(function(item, index, array){
								           if(item.name === '사과') 
								    	      return item;
				      });
	*/
	
	const apple_arr = fruit_Arr_5.filter(item => item.name === '사과');
	
	console.log(apple_arr); // (2) [{name: '사과', price: 1000}, {name: '사과', price: 3000}]
	
	for(let apple of apple_arr) {
		console.log(`제품명:${apple.name}, 가격:${apple.price.toLocaleString('en')}원`);
	}
	// 제품명:사과, 가격:1,000원
	// 제품명:사과, 가격:3,000원 
	
	const watermelon_arr = fruit_Arr_5.filter(item => item.name === '수박');
	
	console.log(watermelon_arr); // []
	
	///////////////////////////////////////////////////////////////////
	
	// === 객체배열에서 price(가격)대로 물건 검색하기 === // 
	const fruit_Arr_6 = [ {name:'사과',  price:1000},
		                  {name:'딸기',  price:2000},
		                  {name:'오렌지', price:1500},
		                  {name:'포도',  price:2500},
		                  {name:'키위',  price:3000} ];
	
	let html = `<ul>`;
	
	for(let item of fruit_Arr_6) {
		html += `<li>${item.name}&nbsp;${item.price.toLocaleString('en')}원</li>`;
	}// end of for------------------
	
	html += `</ul>`;
	
	document.getElementById("display_all_fruit").innerHTML = html;
	////////////////////////////////////////////////////////////////
	
	const btnSearch = document.getElementById("btnSearch");
	
	btnSearch.onclick = ()=>{
		const minPrice = document.getElementById("minPrice").value;
		const maxPrice = document.getElementById("maxPrice").value;
		
		if( minPrice.trim() == "" || maxPrice.trim() == "" ) {
			alert("최저가격 및 최고가격을 입력하셔야 합니다.");
			return;
		}
		
		else {
			const n_minPrice = Number(minPrice);
			const n_maxPrice = Number(maxPrice);
			
			if( isNan(n_minPrice) ||  isNan(n_maxPrice) ) {
				// NaN ==> Not a Number
				// isNan(n_minPrice) 은 n_minPrice 가 숫자가 아니라면 true, 숫자라면 false
				alert("숫자로만 입력하세요!!");	
				return;
			}
			
			else if( n_minPrice > n_maxPrice ) {
				alert("최저가격은 최고가격 보다 작거나 같아야 합니다.");
				return;
			}
			
			else {
				
				/* 
				const fruit_search_Arr = fruit_Arr_6.filter( function(item, index, array) {
					                                                  if( n_minPrice <= item.price && item.price <= n_maxPrice ) { 
					                                                	  return item;
					                                                  }
				                                             } );
				 */
				const fruit_search_Arr = fruit_Arr_6.filter( item => { n_minPrice <= item.price && item.price <= n_maxPrice }); 
											            
				console.log(fruit_search_Arr);
				
				let html;
				
				if(fruit_search_Arr.length > 0) {
				
					html = `<ul>`;
					for(let item of fruit_search_Arr) {
						html += `<li>${item.name}&nbsp;${item.price.toLocaleString('en')}원</li>`;
					}// end of for--------------------
					html += `</ul>`;
				}
				else {
					html = `검색조건에 만족하는 과일은 없습니다.`;
				}
				
				document.getElementById("display_search_fruit").innerHTML = html; 
				
			}
		}
		
	};
	
	////////////////////////////////////////////////////////////////
	   // ---- ***** 배열명.findIndex() ***** ---- //
	   // ES6에서 새로 도입된 메소드로서 판별함수의 조건에 만족하는 배열요소가 있으면 첫번째 배열요소의 인덱스번호만 리턴 시켜주고 끝내고, 
	   // 판별함수의 조건에 만족하는 배열요소가 없으면 -1 이 나온다.
	   
	   /*
	   let index = fruit_Arr_6.findIndex( function(item, index, array) {
                                                 if( item.price > 1000 )
                                               	  	return item;
                                               	 });
	   */
	   let index = fruit_Arr_6.findIndex( item => item.price > 1000 );
	   
	   console.log("index:" + index); // index => 1
	   
	  
	// ---- ***** 배열명.indexOf(찾을요소, 검색출발인덱스번호) ***** ---- //
	   // 배열명에서 찾을요소와 일치하는 배열요소가 있으면 첫번째 배열요소의 인덱스번호만 리턴 시켜주고 끝내고, 배열요소가 없으면 -1 이 나온다.
	   
	   const subject_arr = ["자바","오라클","HTML","CSS","javascript","오라클","자바","HTML","오라클"];
	   
	   index = subject_arr.indexOf("오라클", 0); // 검색출발인덱스번호를 생략하면 0 으로 된다. 
	   console.log(`index 번호 : ${index}`); // index 번호 : 1
	   
	   index = subject_arr.indexOf("안녕하세요", 0); // 검색출발인덱스번호를 생략하면 0 으로 된다. 
	   console.log(`index 번호 : ${index}`); // index 번호 : -1 
	   
	   
	   // 배열요소 "오라클" 의 모든 index 번호를 찾아서 배열로 만들기 //
	   const index_arr = [];
	   index = subject_arr.indexOf("오라클"); //  1 
	   while(index != -1) {
	      index_arr.push(index); // [1] [1,5] [1,5,8]
	      index = subject_arr.indexOf("오라클", index+1); // 5  8  -1
	   }
	   
	   console.log(index_arr);  // (3) [1, 5, 8]
	
	
	////////////////////////////////////////////////////////////////   
	// ---- ***** 배열명.some() ***** ---- //
	   // 배열명에서 판별함수의 조건에 만족하는 배열요소가 하나라도 있으면 true 를 리턴 시켜주고 조건검사를 중지한다.
	   // 배열명에서 판별함수의 조건에 만족하는 배열요소가 하나라도 없으면 false 를 리턴 시켜준다.
	   
	   // 배열 furit_Arr_6에서 price가 2000 이상인 배열요소가 있는지 검사한다.
	   
	   /* let bool = fruit_Arr_6.some(function(item,index,array){
		   								if(item.price >= 2000) {
		   									console.log(item.name);
		   									return true;
		   								}
	   								});
	   console.log(bool);
	   */
	   
	   bool = fruit_Arr_6.some(item => item.price >= 2000);
	   console.log(fruit_Arr_6);
	   

	 //////////////////////////////////////////////////////////////// 		
	 // ---- ***** 배열명.every() ***** ---- //
	 // 배열명에서 판별함수의 조건에 만족하는 배열요소가 하나라도 없으면 false 를 리턴 시켜주고 조건검사를 중지한다.
	 // 배열명에서 판별함수의 조건에 만족하는 배열요소가 모두 존재해야만 true 를 리턴 시켜준다.
	 
	 // 배열 furit_Arr_6에서 price가 모두 1000 이상인지 검사한다.
	   bool = fruit_Arr_6.every(function(item,index,array){
		   								if(item.price >= 1000) {
		   									console.log(item.name); // 사과 딸기 오렌지 포도 키위
		   									return true;
		   								}
		   								else {
		   									console.log(item.name+ "의 가격은 1000원 이상입니다.");
		   								}
	   								});
	   console.log(bool);
	
	   // 또는
	   bool = fruit_Arr_6.every(item => item.price >= 1000);
	   console.log(bool);
	   
	 // 배열 furit_Arr_6에서 price가 모두 2000 이상인지 검사한다.
	   bool = fruit_Arr_6.every(item => item.price >= 2000);
	   console.log(bool);
	   
	   
	   
</script>

</body>
</html>
